2014-01-29-21:03:10 Problems with  ^c and ^\ not Doing The Right Thing.


								 On Sat, Jan 25, 2014 at 1:31 AM, Alex Shinn <alexshinn@gmail.com> wrote:
								 > On Sat, Jan 25, 2014 at 7:55 AM, Ciprian Dorin Craciun
								 > <ciprian.craciun@gmail.com> wrote:
								 >>
								 >>     Hello all!
								 >>
								 >>     I'm trying to use Chibi's FFI generator to wrap a function that
								 >> has the following signature, and whose contract says that the `output`
								 >> should be `free`-ed by the caller.
								 >>
								 >>        bool spit_string (char * * output)
								 >>
								 >>     Thus I've defined the function as:
								 >>
								 >>        (define-c boolean spit_string ((result reference free string)))
								 >>
								 >>     However in the resulting C code (with Chibi 0.6.1), doesn't seem
								 >> to call any `free`.  In fact either with `free` type modifier, or
								 >> without, the resulting C code is identical.
								 >
								 >
								 > Unfortunately Chibi doesn't have a way to free C strings
								 > currently.  Chibi strings are actually offsets into bytevectors,
								 > which are defined as
								 >
								 >     struct {
 								 >       sexp_uint_t length;
								 >       char data[];
								 >     } bytes;
								 >
								 > which means we need to copy C strings to be used in Chibi.

								 This is OK, I don't mind the cloning of the data.


								 > We could update chibi-ffi to free the C string immediately
								 > after we've copied it into Chibi.

								 Exactly.  This is what I would have expected after I've read the
								 documentation for the `free` modifier.  Because currently it leaks the
								 original string.


								 >>     Moreover replacing `string` with some `data` structure that I've
								 >>
								 >> previously defined, doesn't seem to change the situation.
								 >
								 >
								 > If you return a pointer with the "free" modifier, it should call
								 >
								 >   sexp_make_cpointer(ctx, type, ptr, SEXP_FALSE, 1)
								 >
								 > where the final "1" means to call the finalizer on gc
								 > collection, and where the default finalizer for a foreign
								 > pointer is "free".






The command
|    Yeth? 'abc

doesn't print the symbol 'abc We certainly need to check strings like
"Run Me" for their presence, but (by fiat) we insist that a single
quote is a scheme symbol

Now quotes are treated as indicators that the text is to be quoted
SUPERSEDED 2015-02-23-17:50:56 




2014-08-13-20:34:15 Mysteriously exits (probably something to do with files closing)
RESOLVED 2014-08-13-20:34:53 pipes are *buggered*

2014-08-13-20:35:07 Doesn't appear to be a terminal (more(1) just cats)
						  2014-11-26-16:06:01  Doesn't "cat" now, but never gets terminal input
						  							  "ls -lrt | more"
													  pauses, but never continues.
													  
RESOLVED 2014-08-13-20:36:33 Doesn't dispatch scheme expressions at the moment.




2014-11-26-15:47:45  Things happen in odd orders with sets of s-expressions:
|	 Yeth? (begin (display 1)(display 2)(display 3)(newline))
|	 123
|
|	 Yeth? (display 1)(display 2)(display 3)(newline)
|	 321Yeth? 
|
|	 The second is "backwards" -- suggests that there is a recursive component to evaluating
|	 things that I probably don't want
|
|
|    ** 2014-12-29-09:40:20 Scheme expressions aren't mixing with commands and conditionals
|
|	 Yeth? #t || echo yes
|	 Yeth? #f || echo yes			
|
|	 ***** Scheme expressions *are* mixing with commands and conditionals, I misdiagnosed 
|	 ***** things. Here the # is treated like the beginning of a comment line. Noting that
|	 ***** '(or)' => #f   and that  '(and') -> #t,
|
|	 Yeth? (or) || echo Yes
|	 Yeth? (or) && echo Yes
|	 Yes
|	 Yeth? (and) && echo Yes
|	 Yes
|	 Yeth? (and) || echo Yes
|	 Yeth? 
|
|	 which *is* backwards, but never mind.
|
RESOLVED 2014-12-30-19:24:25

2014-12-??-??:??:?? Wonkiness in order of execution
|
|    Yeth? (display 1)(display 2)(display 3)(newline)
|
|	 321Yeth?
|	 Yeth? (begin (display 1)(display 2)(display 3)(newline))
|	 123
|	 Yeth?
|
|	 Probably some odd backwards recursion.....

The problem only occurred when there was no spaces between the s-expressions, and the reason
was that it was being evaluated in evaluate_scheme_expression as something like
(display-string %s) .... changed to (display-string ((lambda () %s))) and evaluation is as it
ought to be.
RESOVED 2015-02-23-17:45:39 	 

** 2014-12-30-15:06:51 Need to make it so that single quotes are treated like quotes on *commands*

						  quoted list or embedded in a scheme expression. Commands like

						        'command-name with embedded spaces' 
						  
						  ought to work. Currently

						        'cat' /etc/issue 

						  will cause a segv.
RESOLVED 2015-02-23-17:49:10 

						  
2015-02-22-11:21:16 #f produces a true value
the string length in the strncmp(cp,"#t...) was 1, not 2 in the tokening code
RESOLVED 2015-02-22-21:30:10 

2015-02-22-21:32:41 It looks like things are being fired off in the background by default.
The problem was that make_background was treated as boolean when what was passed was a bit flag.
RESOLVED 2015-02-23